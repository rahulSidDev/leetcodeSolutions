# Queue: First-in-First-out Data Structure

In a FIFO (first in first out) data structure the element that is added first is processed first. An example of FIFO DS is the Queue. Adding an element operation is called 'enqueue' and the element is added to the end of the Queue, while deleting an element is called 'dequeue' and the first element of the Queue is removed.

## Problem: Design Circular Queue

The array to store queue elements is initialised as having 'k' 'null' values. The head index and the tail index are initialised to 'null', the 'length' variable (stores the no. of actual elements in the queue) is initialised to 0.
The 'enQ' function checks if the data array is empty, if it is then the first element is stored in the data array with the head and tail indices being 0 and the 'length' variable being 1 and finally 'true' is returned. If the data array is full then it cannot store any more values and false is returned. For regular cases of insertion the tail index is updated by incrementing by and taking the modulus with the length of the data array which helps the tail index stay in the range of `[0, length(dataarray))`. Then the input value is inserted at the tail index in the data array, the 'length' variable is incremented by 1, and 'true' is returned.
The 'deQ' function returns 'false' if there are no elements in the data array since no values can be removed. If there is just one element in the data array then the element at the head index is assigned to 'null', the head and tail indices are set to 'null', the 'length' variable is decremented by 1, and 'true' is returned. For other regular cases the element at the head index in the data array is set to 'null', the head index is updated using the same logic as updating tail index the 'enQ' function, the 'length' variable is decremented by 1 and 'true' is returned.

# Queue and BFS

The Queue DS is used in Breadth First Search (BFS) algorithms of Graphs. As each node is traversed its child nodes are added to the queue. After the current node is processed the immediate child node of itself is taken out of the queue for processing. Since the child nodes closer to the root node are considered first in the processing order a FIFO data structure is appropriate to use in BFS which is why queue is used.

## Problem: Number of Islands

The algorithm uses breadth first search (bfs) to visit all the island elements and mark them as visited, as each island is visited the count will also be increased. Each element in the 2D matrix is iterated over and if an element is equal to '1' and it is not in visited set then it is appended to the queue to have bfs search done on it, also the island count is incremented because current element is the start of a new island. A 'while' loop is run until the queue is empty, for each iteration the element is dequeued all of the valid neighbors from horizontal and vertical direction of the current element are added to the queue and the visited set. For a neighbor to be valid it must have the value '1', its row and column indices must not be out of bounds, and it must not already be visited before. After the 'while' loop ends the entire island surrounding the current element is visited and mapped. After all iterations end 'islandCount' will have the no. of islands and it will be returned.

## Problem: Open the Lock

The algorithm starts by adding the 'deadends' array elements to the visited set so that they can be avoided later on when all possible lock combinations are being explored. If the combination '0000' is in the 'deadends' array and the visited set then -1 is returned because no other lock value is reachable. A 'while' loop is started that goes on until the queue is empty, for each iteration the entire queue is iterated over and all the possible lock combos are calculated for each element in the queue. When going over the entire current queue the element is dequeued, if it is equal to the current target then the no. of turns is returned. Every possible adjacent lock combination is calculated for every dequeued element by incrementing and decrementing every lock value in the dequeued element, and if the possible combination is not in the visited set already then it is appended to the queue. After the elements in the current queue are iterated over the no. of turns value is incremented by 1 because calculating each possible lock combo takes one turn value. After all iterations are done the no. of turns is returned.

## Problem: Perfect Squares

Firstly all the perfect squares that are less than equal to input 'n' are calculated and added to the 'allSquares' array. If the last element of this array is equal to 'n' then immediately 1 is returned as by choosing just one perfect sqaure we can bring the sum to 'n'. The input 'n' is added to the squares set and a 'while' loop is started until the length of squares set becomes 0. Until the squares set becomes 0 all the elements of the squares set are iterated over. The perfect square values from 'allSquares' that are less than the current set element are subtracted from the current element. If the difference is 0 then the that means the sum of perfect squares equaling 'n' is reached and the minimum no. of squares is returned, otherwise the difference is added to a temporary set. After the elements in the squares set are all iterated over the temporary set is assigned to the current square set and the iteration continues. Before the elements of the squares set are iterated over the min no. of squares value is incremented by 1 because calculating the difference between squares set elements and perfect squares counts towards using one more perfect square in the sum equaling 'n'. After all iteration is done the min no. of squares is returned.

# Stack: Last in First Out Data Structure

In a LIFO data structure, the newest element added to the queue will be processed first. Different from the queue, the stack is a LIFO data structure. Typically, the insert operation is called push in a stack. Similar to the queue, a new element is always added at the end of the stack. However, the delete operation, pop, will always remove the last element which is opposite from the queue.

## Problem: Min Stack

The stack is represented by an array. The `push` function simply appends the input value onto the stack array. The `pop` function takes the stack array and splices it to only include indices from 0 to the second last index and then the spliced array is assigned to the stack array effectively removing the last element from the array. The `top` function simply returns the last element from the stack array using the `len(stack)-1` index. The `getMin` function simply iterates over the stack array and finds the minimum element and returns it.

## Problem: Valid Parentheses

An empty stack is created and each character in the input string is iterated over. If the current char is an opening bracket then it is placed inside of the stack, otherwise if curr char is closing bracket and the stack is empty then that means the input string starts with a closing bracket in which case it's not possible for the input string to be valid, and so 'false' is returned immediately. If the stack is not empty with the curr char being a closing bracket then the topmost opening bracket is popped off the stack and it is checked if the opening bracket corresponds to the current closing bracket. If it does'nt then the input string is not valid and 'false' is returned. After the iteration over the string is complete 'true' is returned if all the opening brackets are matched with closing brackets and the stack length is 0, otherwise 'false' is returned.

## Problem: Daily Temperatures

An empty stack to store array indices is created and another array 'answer' of zeroes with length equal to the input temperatures array is created to store the answers. The input array of temperatures is iterated over and appended to the stack. If the current temperature value in any iteration is larger than the value pointed to by the last index in the temperatures stack then an inner iteration is started. The inner iteration continues until the stack becomes empty or the temperature value pointed to by the last indice in the stack becomes greater than or equal to the current temperature value from the input array. The indices are continuously popped from the stack and difference between the current temperature's index and the popped index are inserted in the 'answer' array at the position of the popped index. Logically the algorithm adds temperature index to the stack until a temperature larger than the one previously pushed onto the stack is encountered, then the stack is popped until the last temperature in the stack is no longer smaller than the current temperature, the difference in indices gives the 'ith day to get a warmer temperature', and so the difference is stored inside of the 'answer' array. Finally the 'answer' array is returned.

## Problem: Evaluate Reverse Polish Notation

An empty stack is created and all the tokens in the input array are iterated over. If a token is not an operator (`+, -, *, /`) then it is added to the stack. If it is an operator then the last two numbers from the stack are popped and the 'performOperation' function is called by passing in the first two popped no.s and the current operator as arguments. The function will perform the operation on the two no.s and return the result which inturn is added back to the stack. After the iteration is done over all tokens there will be just one element left in the stack which is answer to the whole expression, that element is popped and returned.

# Stack and DFS

The Depth-first-search algorithm starts with the root node, then it visits the first child node of the root, and then further first child of the previous node and so on until it reaches the end of the graph or tree. Once the end is reached the algo traces back to previous nodes and chooses different child nodes to traverse different paths. For this algo a stack is a preferable data structure to handle traversal because when backtracking the last node visited is the one processed first i.e. LIFO order.

## Problem: Number of Islands (again)

A stack is used to perform DFS on the input 2D array to mark and count each island that occurs in the array. By using two nested loops each element in the input 2D array is iterated over. If the current element has not been visited before (not present in 'visitedSet') and if the element is equal to '1' then the element is marked as visited and the 'dfsRecurse' element is called by passing in the 2D array, current element indices, and the visited set. In the 'dfsRecurse' function all the neighbouring elements (top, down, left, right) of the current element that are valid are added to an array. Then each neighbor is iterated over and if it is not visited before and if it is equal to value '1' then it is marked as visited and the dfs function is called again by passing in the current neighbor. In this way DFS traversal is done by finding all the neighbors of current element, traversing over each neighbor, recursing and finding the next element's neighbors and so on. After all recursions are done and returned an entire island would be visited and marked and so the 'islandCount' is incremented by 1. After all iteration the 'islandCount' is returned

## Problem: Clone Graph

An empty set is created to mark nodes that are visited, a hash map is created to map the original nodes to their corresponding new copy nodes, and a stack is created to perform DFS with the first input node inside of it. Iteration is done until the stack becomes empty as no more nodes are left to visit. For each iteration nodes are popped from the stack and if they have been visited then the iteration simply moves to the next node in the stack. Otherwise the current node is marked as visited and if it is not in the hash map then it is added there mapping itself to its new copy node. Then the neighbor nodes of the current node are iterated over and if a neighbor is not in the hashmap then its added there mapping itself to the new copy neighbor node. The copy neighbor node is accessed from the hashmap and added to the copy current node's neighbor list which is also accessed from the hashmap, in this way the connections between nodes are copied alongside the nodes themselves. The neighbor node is added to the stack and the iteration moves on to the next neighbor and the DFS traversal continues. Finally the copy node of the original input node from the hashmap is returned since it serves as the starting node for the copy graph.

## Problem: Target Sum

The algorithm uses a dynamic programming table to store the answers. Each entry `dp[index][sum]` in the dp array holds the no. of ways to reach `sum` using elements upto `index` from the original input array. The `index` will be upto the length of the input array and the `sum` will be two times the sum of all array elements because the range of possible values for the sum can be between `[-totalSum, totalSum]` by choosing all negative values from the input array and choosing all positive values from the input array. The dp table array is originally all zeroes, then the no. ways to reach sum values `nums[0]` and `-nums[0]` by using the first element of the array is incremented to 1 in the table since there is exactly one way to reach the sum values using just one element. The elements from the dp table are all iterated over and for each entry in the dp table that is greater than 0 to achieve sum equal to `sumVal+totalSum` using elements from the array upto `index-1`, it is added to the dp entries for getting the sum value `sumVal+totalVal+nums[index]` and `sumVal+totalVal-nums[index]` using `index` no. elements from the array. Finally the no. ways to get 'target' sum value using all the elements from the input array is inside `dp[index][totalSum+target]` and so it is returned.

## Problem: Binary Tree Inorder Traversal

An empty stack and a result array are created. Then depth first traversal is done by appending the root to the stack and moving it to the left child node until the leaf node of the tree is reached. Then the last node added to the stack is popped and appended to the result array and the root node is assigned the right child of the popped node. If at any point the stack becomes empty then the loop is broken. Overall depth-first traversal of the tree will be done and the nodes will be appended to the result array in 'in-order' fashion. Finally the result array will be returned.

# Conclusion

## Problem: Implement Queue using Stacks

Two empty stacks are created where stack2 is will be the reverse of stack1 basically making it have the same order as a queue. The push operation will add the value to stack1 and then reverse it and assign it to stack2. It works since the push operation is the same as for both stack and queue. The pop operation will remove the last element from stack2, invert it and assign it to stack1. It works because stack2, being the reverse of stack1, is the same order as a queue, and so performing a pop operation on it is equivalent to performing a dequeue operation on a queue. The 'peek' function returns last element of stack2 which is essentially the first element of queue. The 'empty' function returns true if length of stack1 is 0 (length of stack2 can also be checked) otherwise false.

## Problem: Implement Stack using Queues

Follows the same logic as the above problem except in reverse.

## Problem: Decode String

An empty stack is created, a variable 'currNum' is created to store the number encountered while iterating through the string, and a variable 'currString' is created to store characters inside of the brackets in the input string. The characters in the input string are iterated over. If the character is a number then 'currNum' is updated by multiplying itself by 10 (to account for multiple digit numbers) and adding the int value of the character to itself. If no other case occurs with the current character in the iteration then it is simply added to the 'currString' variable. When an opening bracket is encountered then the 'currString' and 'currNum' are appended to the stack and both are initialised to 0 and empty string. When the closing bracket is encountered then the last two elements from the stack are popped which are the previous num and the previous string respectively. The 'currString' is repeated previous num times, it is added to the previous string, and assigned back to the 'currString'. When the iteration is done 'currString' is returned as it stores the decoded string.

## Problem: Flood Fill

The algorithm starts by adding the input row and column indices into the queue, creating the visited set to mark elements after visiting them, and storing original value of `image[sr][sc]`. Then iteration is performed on the queue until the queue becomes empty. In each iteration the first element in the queue is dequeued and it is set to the input color and marked as visited. Then breadth-first traversal is done by adding all valid neighbors of current element (must be within bounds, must not be visited, and must be equal to the original value saved before) into the queue so that they can be dequeued one by one as the iteration goes and processed. After the iteration is done all the clusters of elements equal to the original value will be changed to the input color as desired.

## Problem: 01 Matrix

An empty queue is created for breadth-first traversal and an empty visited set is created to mark elements that are visited. The entire matrix is iterated over and each element that is equal to 0 is marked as visited and added to the queue. Then the queue is iterated over until the queue becomes empty, breadth-first traversal is done by dequeueing the curr element from the queue and finding all vertical and horizontal neighbors of it. For each valid neighbor of curr element (not outside bounds and not already visited) its value is assigned to the value the curr element plus 1, then it is marked as visited and added to the queue. Visually speaking, for each element in the matrix bfs is done and when element 1 is found in the neighbor of element 0 then the nearest 0 value for it is set as 1. When element 1 is found in the neighbor of previous element 1 then its nearest 0 value is set to 2 and so on. In this way the orignal matrix is transformed into the answer matrix with the nearest 0 value of each element stored in place. The same input matrix is returned as answer in the end.

## Problem: Keys and Rooms

An empty set is created to keep all the visited rooms, then the first room is marked as visited by adding it to the set. A queue is created by adding all the keys in the first room in it. Then with iteration all the possible rooms are visited and marked. Until the queue becomes empty the iteration continues, the front key is dequeued and if the room the curr key corresponds to has not been visited then it is marked as visited, and all the keys inside of the room corresponding to the currkey are iterated over and added to the queue if they have not already been visited. Finally when the iteration is done if all the rooms are visitable then all of them would have been visited and marked, meaning the length of 'visitedRooms' set and the input 'rooms' array would be the same. This condition is checked and 'True' or 'False' is returned accordingly.